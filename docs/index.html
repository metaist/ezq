<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ezq API documentation</title>
<meta name="description" content="Simple wrapper for python `multiprocessing` and `threading` â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>ezq</code></h1>
</header>
<section id="section-intro">
<p>Simple wrapper for python <code>multiprocessing</code> and <code>threading</code>.</p>
<p><a href="https://github.com/metaist/ezq/actions"><img alt="Build Status" src="https://img.shields.io/github/actions/workflow/status/metaist/ezq/.github/workflows/ci.yaml?branch=main&amp;style=for-the-badge"></a>
<a href="https://pypi.org/project/ezq"><img alt="ezq on PyPI" src="https://img.shields.io/pypi/v/ezq.svg?color=blue&amp;style=for-the-badge"></a>
<a href="https://pypi.org/project/ezq"><img alt="Supported Python versions" src="https://img.shields.io/pypi/pyversions/ezq?style=for-the-badge"></a></p>
<p><a href="https://github.com/metaist/ezq/blob/main/CHANGELOG.md">Changelog</a> - <a href="https://github.com/metaist/ezq/issues">Issues</a> - <a href="https://metaist.github.io/ezq/">Documentation</a></p>
<h2 id="why">Why?</h2>
<p><code><a title="ezq" href="#ezq">ezq</a></code> makes it easy to connect subprocesses and threads (both considered "workers") using queues with a simpler API than <a href="https://docs.python.org/3/library/concurrent.futures.html"><code>concurrent.futures</code></a>, <a href="https://docs.python.org/3/library/multiprocessing.html"><code>multiprocessing</code></a>, or <a href="https://docs.python.org/3/library/threading.html"><code>threading</code></a>.</p>
<h2 id="install">Install</h2>
<pre><code class="language-bash">pip install ezq
</code></pre>
<h2 id="example-quick-start">Example: Quick Start</h2>
<p>If you just want to apply a function to some inputs, you can use <code><a title="ezq.map" href="#ezq.map">map()</a></code> to run it on all available CPUs and get the results back.</p>
<pre><code class="language-python">import ezq
print(list(ezq.map(lambda x: x * 2, range(6))))
# =&gt; [0, 2, 4, 6, 8, 10]
</code></pre>
<h2 id="example-sum-messages">Example: Sum Messages</h2>
<p>Here's a simple example of a worker that reads from an input queue, sums up the messages, and puts the result on an output queue.</p>
<pre><code class="language-python">import ezq


def worker(q, out):
    &quot;&quot;&quot;Add up all the messages.&quot;&quot;&quot;
    total = 0
    for msg in q:  # read a message from the queue
        total += msg.data

    # after reading all the messages, write the total
    out.put(total)


def main():
    &quot;&quot;&quot;Run several workers.&quot;&quot;&quot;
    # Step 1: Creates the queues and start the workers.
    q, out = ezq.Q(), ezq.Q()  # input &amp; output queues
    workers = [ezq.run(worker, q, out) for _ in range(ezq.NUM_CPUS)]
    # workers are all running

    # Step 2: Send work to the workers.
    for i in range(1000):
        q.put(i)  # send work

    # Step 3: Tell the workers to finish.
    q.stop(workers)
    # workers are all stopped

    # Step 4: Process the results.
    want = sum(range(1000))
    have = sum(msg.data for msg in out.items())
    assert have == want
    print(have)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="typical-worker-lifecycle">Typical worker lifecycle</h2>
<ul>
<li>
<p>The main process <a href="#create-queues">creates queues</a> with <code><a title="ezq.Q" href="#ezq.Q">Q</a></code>.</p>
</li>
<li>
<p>The main process <a href="#create-workers">creates workers</a> with <code><a title="ezq.run" href="#ezq.run">run()</a></code> (alias for <code><a title="ezq.Worker.process" href="#ezq.Worker.process">Worker.process()</a></code>) or <code><a title="ezq.run_thread" href="#ezq.run_thread">run_thread()</a></code> (alias for <code><a title="ezq.Worker.thread" href="#ezq.Worker.thread">Worker.thread()</a></code>).</p>
</li>
<li>
<p>The main process <a href="#send-data">sends data</a> using <code><a title="ezq.Q.put" href="#ezq.Q.put">Q.put()</a></code>.</p>
</li>
<li>
<p>The worker <a href="#iterate-over-messages">iterates over the queue</a>.</p>
</li>
<li>
<p>The main process <a href="#end-the-queue">ends the queue</a> with <code><a title="ezq.Q.stop" href="#ezq.Q.stop">Q.stop()</a></code>.</p>
</li>
<li>
<p>The worker returns when it reaches the end of the queue.</p>
</li>
<li>
<p>(<em>Optional</em>) The main process <a href="#process-results">processes the results</a>.</p>
</li>
</ul>
<h2 id="process-vs-thread"><code>Process</code> vs <code>Thread</code></h2>
<p><code><a title="ezq" href="#ezq">ezq</a></code> supports two kinds of workers: <code>Process</code> and <code>Thread</code>. There is a lot of existing discussion about when to use which approach, but a general rule of thumb is:</p>
<ul>
<li>
<p><code>Process</code> is for <em>parallelism</em> so you can use multiple CPUs at once. Ideal for <strong>CPU-bound</strong> tasks like doing lots of mathematical calculations.</p>
</li>
<li>
<p><code>Thread</code> is for <em>concurrency</em> so you can use a single CPU to do multiple things. Ideal for <strong>I/O-bound</strong> tasks like waiting for a disk, database, or network.</p>
</li>
</ul>
<p>Some more differences:</p>
<ul>
<li>
<p><strong>Shared memory</strong>: Each <code>Process</code> worker has <a href="#beware-pickle">data sent to it via <code>pickle</code></a> (actually <a href="https://github.com/uqfoundation/dill"><code>dill</code></a>, a <code>pickle</code> replacement) and it doesn't share data with other workers. By contrast, each <code>Thread</code> worker shares its memory with all other workers on the same CPU, so it can <a href="#beware-shared-state">accidentally change global state</a>.</p>
</li>
<li>
<p><strong>Queue overhead</strong>: <code><a title="ezq.Q" href="#ezq.Q">Q</a></code> <a href="#create-queues">has more overhead</a> for <code>Process</code> workers than <code>Thread</code> workers.</p>
</li>
<li>
<p><strong>Creating sub-workers</strong>: <code>Process</code> and <code>Thread</code> workers can create additional <code>Thread</code> workers, but <a href="#create-workers">they cannot create additional <code>Process</code> workers</a>.</p>
</li>
</ul>
<h2 id="create-queues">Create queues</h2>
<p>In the main process, create the queues you'll need. Here are my common situations:</p>
<ul>
<li>
<p><strong>0 queues</strong>: I'm using a simple function and can ask <code><a title="ezq.map" href="#ezq.map">map()</a></code> to make the queues for me.</p>
</li>
<li>
<p><strong>1 queue</strong>: the worker reads from an input queue and persists the result somewhere else (e.g., writing to disk, making a network call, running some other program).</p>
</li>
<li>
<p><strong>2 queues</strong> (most common): the worker reads from an input queue and write the results to an output queue.</p>
</li>
<li>
<p><strong>3 queues</strong>: multiple stages of work are happening where workers are reading from one queue and writing to another queue for another worker to process.</p>
</li>
</ul>
<p><strong>NOTE:</strong> If you're using <code>Thread</code> workers, you can save some overhead by passing <code>Q("thread")</code>. This lightweight queue also doesn't use <code>pickle</code>, so you can use it to pass hard-to-pickle things (e.g., database connection).</p>
<pre><code class="language-python">q, out = ezq.Q(), ezq.Q() # most common
q2 = ez.Q(&quot;thread&quot;) # only ok for Thread workers
</code></pre>
<h2 id="a-worker-task-is-just-a-function">A worker task is just a function</h2>
<p>In general, there's nothing special about a worker function, but note:</p>
<ul>
<li>
<p>If you're using <code>Process</code> workers, all arguments are <a href="#beware-pickle">passed through <code>pickle</code> first</a>.</p>
</li>
<li>
<p>We don't currently do anything with the return value of this function (unless you use <code><a title="ezq.map" href="#ezq.map">map()</a></code>). You'll need an output queue to return data back to the main process/thread.</p>
</li>
</ul>
<h2 id="create-workers">Create workers</h2>
<p>In the main process, create workers using <code><a title="ezq.run" href="#ezq.run">run()</a></code> or <code><a title="ezq.run_thread" href="#ezq.run_thread">run_thread()</a></code> which take a function and any additional parameters. Typically, you'll pass the queues you created to the workers at this point.</p>
<p><strong>NOTE:</strong> <code>Process</code> and <code>Thread</code> workers can create additional <code>Thread</code> workers, but <strong>they cannot create additional <code>Process</code> workers</strong>.</p>
<h2 id="send-data">Send data</h2>
<p>Once you've created the workers, you send them data with <code><a title="ezq.Q.put" href="#ezq.Q.put">Q.put()</a></code> which creates <code><a title="ezq.Msg" href="#ezq.Msg">Msg</a></code> objects and puts them in the queue. Each message has three attributes (all optional):</p>
<ul>
<li>
<p><code>data: Any</code> - This is the data you want the worker to work on.</p>
</li>
<li>
<p><code>kind: str</code> - You can use this to send multiple kinds of work to the same worker. Note that the special <code>END</code> kind is used to indicate the end of a queue.</p>
</li>
<li>
<p><code>order: int</code> - This is the message order which can help you reorder results or ensure that messages from a queue are read in a particular order (that's what <code><a title="ezq.Q.sorted" href="#ezq.Q.sorted">Q.sorted()</a></code> uses).</p>
</li>
</ul>
<h2 id="beware-pickle">Beware <code>pickle</code></h2>
<p>If you are using <code>Process</code> workers, everything passed to the worker (arguments, messages) is first passed to <code>pickle</code> (actually, <a href="https://github.com/uqfoundation/dill"><code>dill</code></a>). Anything that cannot be pickled with dill (e.g., database connections), cannot be passed to <code>Process</code> workers. Note that <code>dill</code> <em>can</em> serialize many more types than <code>pickle</code> (e.g. <code>lambda</code> functions).</p>
<h2 id="beware-shared-state">Beware shared state</h2>
<p>If you are using <code>Thread</code> workers, workers can share certain variables, so you need to be careful of how variables are access to avoid accidentally corrupting data.</p>
<h2 id="iterate-over-messages">Iterate over messages</h2>
<p>Inside the worker, iterate over the queue to read each message until the queue ends (<a href="#end-the-queue">see below</a>). If the messages need to be processed in order, use <code><a title="ezq.Q.sorted" href="#ezq.Q.sorted">Q.sorted()</a></code>.</p>
<pre><code class="language-python">for msg in q: # read each message until the queue ends
  ...

for msg in q.sorted(): # read each message in order
  ...
</code></pre>
<h2 id="end-the-queue">End the queue</h2>
<p>After the main process has sent all the data to the workers, it needs to indicate
that there's no additional work to be done. This is done by calling <code><a title="ezq.Q.stop" href="#ezq.Q.stop">Q.stop()</a></code> using the input queue that the workers are reading from and passing the list of workers to wait for.</p>
<p>In some rare situations, you can use <code><a title="ezq.Q.end" href="#ezq.Q.end">Q.end()</a></code> to explicitly end the queue.</p>
<h2 id="process-results">Process results</h2>
<p>If you have an output queue, you may want to to process the results. You can use <code><a title="ezq.Q.items" href="#ezq.Q.items">Q.items()</a></code> to end the queue and read the current messages.</p>
<pre><code class="language-python">import ezq
out = ezq.Q()
...
result = [msg.data for msg in out.items()]
# OR
result = [msg.data for msg in out.items(sort=True)] # sorted by Msg.order
# OR
result = [msg.data for msg in out.items(cache=True)] # cache the messages
</code></pre>
<h2 id="example-read-and-write-queues">Example: Read and Write Queues</h2>
<p>In this example, several workers read from a queue, process data, and then write to a different queue that a single worker uses to print to the screen sorting the results as it goes along.</p>
<p>Note that we use a single <code>writer</code> to avoid clashes or overwriting.</p>
<pre><code class="language-python">import ezq


def printer(out: ezq.Q) -&gt; None:
    &quot;&quot;&quot;Print results in increasing order.&quot;&quot;&quot;
    for msg in out.sorted():
        print(msg.data)


def collatz(q: ezq.Q, out: ezq.Q) -&gt; None:
    &quot;&quot;&quot;Read numbers and compute values.&quot;&quot;&quot;
    for msg in q:
        num = float(msg.data)
        if msg.kind == &quot;EVEN&quot;:
            out.put((num, num / 2), order=msg.order)
        elif msg.kind == &quot;ODD&quot;:
            out.put((num, 3 * num + 1), order=msg.order)


def main() -&gt; None:
    &quot;&quot;&quot;Run several threads with a subprocess for printing.&quot;&quot;&quot;
    q, out = ezq.Q(&quot;thread&quot;), ezq.Q()
    readers = [ezq.run_thread(collatz, q, out) for _ in range(ezq.NUM_THREADS)]
    writer = ezq.run(printer, out)

    for num in range(40):
        kind = &quot;EVEN&quot; if num % 2 == 0 else &quot;ODD&quot;
        q.put(num, kind=kind, order=num)

    q.stop(readers)
    out.stop(writer)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="license">License</h2>
<p><a href="https://github.com/metaist/ezq/blob/main/LICENSE.md">MIT License</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8
&#34;&#34;&#34;Simple wrapper for python `multiprocessing` and `threading`.

.. include:: ../../README.md
   :start-line: 4
&#34;&#34;&#34;

__all__ = (
    &#34;Task&#34;,
    &#34;Context&#34;,
    &#34;ContextName&#34;,
    &#34;Msg&#34;,
    &#34;END_MSG&#34;,
    &#34;MsgQ&#34;,
    &#34;NUM_CPUS&#34;,
    &#34;NUM_THREADS&#34;,
    &#34;IS_MACOS&#34;,
    &#34;Worker&#34;,
    &#34;Q&#34;,
    &#34;run&#34;,
    &#34;run_thread&#34;,
    &#34;map&#34;,
)

# native
from dataclasses import dataclass
from operator import attrgetter
from os import cpu_count
from platform import system
from queue import Empty
from queue import Queue as ThreadSafeQueue
from threading import Thread
from typing import Any
from typing import Callable
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Literal
from typing import Optional
from typing import Sequence
from typing import TYPE_CHECKING
from typing import Union

# lib
from multiprocess import Process  # type: ignore
from multiprocess import Queue

Task = Callable[..., Any]
&#34;&#34;&#34;Task function signature (any `Callable`).&#34;&#34;&#34;

Context = Union[Process, Thread]
&#34;&#34;&#34;Execution contexts (`Process`, `Thread`).&#34;&#34;&#34;

ContextName = Literal[&#34;process&#34;, &#34;thread&#34;]
&#34;&#34;&#34;Execution context names (`&#34;process&#34;`, `&#34;thread&#34;`).&#34;&#34;&#34;


@dataclass
class Msg:
    &#34;&#34;&#34;Message for a queue.&#34;&#34;&#34;

    data: Any = None
    &#34;&#34;&#34;Message data to be transmitted.&#34;&#34;&#34;

    kind: str = &#34;&#34;
    &#34;&#34;&#34;Optional marker of message type.&#34;&#34;&#34;

    order: int = 0
    &#34;&#34;&#34;Optional ordering of messages.&#34;&#34;&#34;


# NOTE: The python `queue.Queue` is not properly a generic.
# See: https://stackoverflow.com/a/48554601
if TYPE_CHECKING:  # pragma: no cover
    MsgQ = Union[Queue[Msg], ThreadSafeQueue]  # pylint: disable=unsubscriptable-object
else:
    MsgQ = Queue

END_MSG: Msg = Msg(kind=&#34;END&#34;)
&#34;&#34;&#34;Message that indicates no future messages will be sent.&#34;&#34;&#34;

## Hardware-Specific Information ##

NUM_CPUS: int = cpu_count() or 1
&#34;&#34;&#34;Number of CPUs on this machine.&#34;&#34;&#34;

NUM_THREADS: int = min(32, NUM_CPUS + 4)
&#34;&#34;&#34;Default number of threads (up to 32).

See: [CPython&#39;s default for this value][1].

[1]: https://github.com/python/cpython/blob/a635d6386041a2971cf1d39837188ffb8139bcc7/Lib/concurrent/futures/thread.py#L142
&#34;&#34;&#34;

IS_MACOS: bool = system().lower().startswith(&#34;darwin&#34;)
&#34;&#34;&#34;`True` if we&#39;re running on MacOS.

Currently, we only use this value for testing, but there are certain features that
do not work properly on MacOS.

See: [Example of MacOS-specific issues][1].

[1]: https://github.com/python/cpython/blob/c5b670efd1e6dabc94b6308734d63f762480b80f/Lib/multiprocessing/queues.py#L125
&#34;&#34;&#34;


class Worker:
    &#34;&#34;&#34;A function running in a `Process` or `Thread`.&#34;&#34;&#34;

    _worker: Context
    &#34;&#34;&#34;Execution context.&#34;&#34;&#34;

    @staticmethod
    def process(task: Task, *args: Any, **kwargs: Any) -&gt; &#34;Worker&#34;:
        &#34;&#34;&#34;Create a `Process`-based `Worker`.

        Args:
            task (Task): function to run
            *args (Any): additional arguments to `task`
            **kwargs (Any): additional keyword arguments to `task`

        Returns:
            Worker: wrapped worker.
        &#34;&#34;&#34;
        # NOTE: On MacOS, python 3.8 switched the default method
        # from &#34;fork&#34; to &#34;spawn&#34; because fork is considered dangerous.
        # Some posts say &#34;forkserver&#34; should be ok.
        # See:  https://bugs.python.org/issue?@action=redirect&amp;bpo=33725
        #
        # if IS_MACOS:
        #     ctx = get_context(&#34;forkserver&#34;)
        # else:
        #     ctx = get_context()
        return Worker(Process(daemon=True, target=task, args=args, kwargs=kwargs))

    @staticmethod
    def thread(task: Task, *args: Any, **kwargs: Any) -&gt; &#34;Worker&#34;:
        &#34;&#34;&#34;Create a `Thread`-based `Worker`.

        Args:
            task (Task): function to run
            *args (Any): additional arguments to `task`
            **kwargs (Any): additional keyword arguments to `task`

        Returns:
            Worker: wrapped worker.
        &#34;&#34;&#34;
        return Worker(Thread(daemon=False, target=task, args=args, kwargs=kwargs))

    def __init__(self, context: Context):
        &#34;&#34;&#34;Construct a worker from a context.

        Args:
            context (Context): a `Process` or a `Thread`
        &#34;&#34;&#34;
        self._worker = context
        self._worker.start()

    def __getattr__(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Delegate properties to the underlying task.

        Args:
            name (str): attribute name

        Returns:
            Any: attribute from the task
        &#34;&#34;&#34;
        return getattr(self._worker, name)


class Q:
    &#34;&#34;&#34;Simple message queue.&#34;&#34;&#34;

    _q: MsgQ
    &#34;&#34;&#34;Wrapped queue.&#34;&#34;&#34;

    _cache: Optional[List[Msg]] = None
    &#34;&#34;&#34;Cache of queue messages when calling `.items(cache=True)`.&#34;&#34;&#34;

    _timeout: float = 0.05
    &#34;&#34;&#34;Time in seconds to poll the queue.&#34;&#34;&#34;

    def __init__(self, kind: ContextName = &#34;process&#34;):
        &#34;&#34;&#34;Construct a queue wrapper.

        Args:
            kind (ContextName, optional): If `&#34;thread&#34;`, construct a lighter-weight
                `Queue` that is thread-safe. Otherwise, construct a full
                `multiprocess.Queue`. Defaults to `&#34;process&#34;`.
        &#34;&#34;&#34;
        if kind == &#34;process&#34;:
            self._q = Queue()
        elif kind == &#34;thread&#34;:
            self._q = ThreadSafeQueue()
        else:  # pragma: no cover
            raise ValueError(f&#34;Unknown queue type: {kind}&#34;)

    def __getattr__(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Delegate properties to the underlying queue.

        Args:
            name (str): name of the attribute to access

        Returns:
            Any: attribute from the queue
        &#34;&#34;&#34;
        return getattr(self._q, name)

    def __iter__(self) -&gt; Iterator[Msg]:
        &#34;&#34;&#34;Iterate over messages in a queue until `END_MSG` is received.

        Yields:
            Iterator[Msg]: iterate over messages in the queue
        &#34;&#34;&#34;
        while True:
            try:
                msg = self._q.get(block=True, timeout=self._timeout)
                if msg.kind == END_MSG.kind:
                    # We&#39;d really like to put the `END_MSG` back in the queue
                    # to prevent reading past the end, but in practice
                    # this often creates an uncatchable `BrokenPipeError`.
                    # q.put(END_MSG)
                    break
                yield msg
            except Empty:  # pragma: no cover
                # queue might not actually be empty
                # see: https://bugs.python.org/issue20147
                continue

    def items(self, cache: bool = False, sort: bool = False) -&gt; Iterator[Msg]:
        &#34;&#34;&#34;End a queue and read all the current messages.

        Args:
            cache (bool, optional): if `True`, cache the messages. This allows you
                to call this method multiple times to get the same messages.
                Defaults to `False`.

            sort (bool, optional): if `True` messages are sorted by `Msg.order`.
                Defaults to `False`.

        Yields:
            Iterator[Msg]: iterate over messages in the queue
        &#34;&#34;&#34;
        if cache:
            if self._cache is None:  # need to build a cache
                self.end()
                self._cache = list(self.sorted() if sort else self)
            return iter(self._cache)

        # not cached
        self.end()
        return self.sorted() if sort else iter(self)

    def sorted(self, start: int = 0) -&gt; Iterator[Msg]:
        &#34;&#34;&#34;Iterate over messages sorted by `Msg.order`.

        NOTE: `Msg.order` must be incremented by one for each message.
        If there are any gaps, messages after the gap won&#39;t be yielded
        until the end.

        Args:
            start (int, optional): initial message number. Defaults to `0`.

        Yields:
            Iterator[Msg]: message yielded in the correct order
        &#34;&#34;&#34;
        prev = start - 1
        key = attrgetter(&#34;order&#34;)
        waiting: List[Msg] = []
        for item in self:
            if not waiting and key(item) == prev + 1:
                prev += 1
                yield item
                continue

            # items came out of order
            waiting.append(item)
            waiting.sort(key=key, reverse=True)  # sort in-place for performance
            while waiting and key(waiting[-1]) == prev + 1:
                prev += 1
                yield waiting.pop()

        # generator ended; yield any waiting items
        while waiting:
            yield waiting.pop()

    def put(self, data: Any = None, *, kind: str = &#34;&#34;, order: int = 0) -&gt; &#34;Q&#34;:
        &#34;&#34;&#34;Put a message on the queue.

        Args:
            data (Any, optional): message data. Defaults to `None`.

            kind (str, optional): kind of message. Defaults to `&#34;&#34;`.

            order (int, optional): message order. Defaults to `0`.

        Returns:
            Self: self for chaining
        &#34;&#34;&#34;
        if isinstance(data, Msg):
            self._q.put(data)
        else:
            self._q.put(Msg(data=data, kind=kind, order=order))
        return self

    def end(self) -&gt; &#34;Q&#34;:
        &#34;&#34;&#34;Add the `END_MSG` to indicate the end of work.

        Returns:
            Self: self for chaining
        &#34;&#34;&#34;
        self._q.put(END_MSG)
        return self

    def stop(self, workers: Union[Worker, Sequence[Worker]]) -&gt; &#34;Q&#34;:
        &#34;&#34;&#34;Use this queue to notify workers to end and wait for them to join.

        Args:
            workers (Worker, Sequence[Worker]): workers to wait for

        Returns:
            Self: self for chaining
        &#34;&#34;&#34;
        _workers = [workers] if isinstance(workers, Worker) else workers

        for _ in range(len(_workers)):
            self.end()

        for task in _workers:
            task.join()

        return self


def run(task: Task, *args: Any, **kwargs: Any) -&gt; Worker:
    &#34;&#34;&#34;Run a function as a subprocess.

    Args:
        task (Task): function to run in each subprocess

        *args (Any): additional positional arguments to `task`.

        **kwargs (Any): additional keyword arguments to `task`.

    Returns:
        Worker: worker started in a subprocess

    .. changed:: 2.0.4
       This function now returns a `Worker` instead of a `Process`.
    &#34;&#34;&#34;
    return Worker.process(task, *args, **kwargs)


def run_thread(task: Task, *args: Any, **kwargs: Any) -&gt; Worker:
    &#34;&#34;&#34;Run a function as a thread.

    Args:
        task (Task): function to run in each thread

        *args (Any): additional positional arguments to `task`.

        **kwargs (Any): additional keyword arguments to `task`.

    Returns:
        Worker: worker started in a thread

    .. changed:: 2.0.4
       This function now returns a `Worker` instead of a `Thread`.
    &#34;&#34;&#34;
    return Worker.thread(task, *args, **kwargs)


def map(
    task: Task,
    *args: Iterable[Any],
    num: Optional[int] = None,
    kind: ContextName = &#34;process&#34;,
) -&gt; Iterator[Any]:
    &#34;&#34;&#34;Call a function with arguments using multiple workers.

    Args:
        func (Callable): function to call

        *args (list[Any]): arguments to `func`. If multiple lists are provided,
            they will be passed to `zip` first.

        num (int, optional): number of workers. If `None`, `NUM_CPUS` or
            `NUM_THREADS` will be used as appropriate. Defaults to `None`.

        kind (ContextName, optional): execution context to use.
            Defaults to `&#34;process&#34;`.

    Yields:
        Any: results from applying the function to the arguments
    &#34;&#34;&#34;
    q, out = Q(kind=kind), Q(kind=kind)

    def worker(_q: Q, _out: Q) -&gt; None:
        &#34;&#34;&#34;Internal call to `func`.&#34;&#34;&#34;
        for msg in _q.sorted():
            _out.put(data=task(*msg.data), order=msg.order)

    if kind == &#34;process&#34;:
        workers = [Worker.process(worker, q, out) for _ in range(num or NUM_CPUS)]
    elif kind == &#34;thread&#34;:
        workers = [Worker.thread(worker, q, out) for _ in range(num or NUM_THREADS)]
    else:  # pragma: no cover
        raise ValueError(f&#34;Unknown worker context: {kind}&#34;)

    for order, value in enumerate(zip(*args)):
        q.put(value, order=order)
    q.stop(workers)

    for msg in out.end().sorted():
        yield msg.data</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="ezq.Context"><code class="name">var <span class="ident">Context</span></code></dt>
<dd>
<div class="desc"><p>Execution contexts (<code>Process</code>, <code>Thread</code>).</p></div>
</dd>
<dt id="ezq.ContextName"><code class="name">var <span class="ident">ContextName</span></code></dt>
<dd>
<div class="desc"><p>Execution context names (<code>"process"</code>, <code>"thread"</code>).</p></div>
</dd>
<dt id="ezq.END_MSG"><code class="name">var <span class="ident">END_MSG</span> :Â <a title="ezq.Msg" href="#ezq.Msg">Msg</a></code></dt>
<dd>
<div class="desc"><p>Message that indicates no future messages will be sent.</p></div>
</dd>
<dt id="ezq.IS_MACOS"><code class="name">var <span class="ident">IS_MACOS</span> :Â bool</code></dt>
<dd>
<div class="desc"><p><code>True</code> if we're running on MacOS.</p>
<p>Currently, we only use this value for testing, but there are certain features that
do not work properly on MacOS.</p>
<p>See: <a href="https://github.com/python/cpython/blob/c5b670efd1e6dabc94b6308734d63f762480b80f/Lib/multiprocessing/queues.py#L125">Example of MacOS-specific issues</a>.</p></div>
</dd>
<dt id="ezq.NUM_CPUS"><code class="name">var <span class="ident">NUM_CPUS</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Number of CPUs on this machine.</p></div>
</dd>
<dt id="ezq.NUM_THREADS"><code class="name">var <span class="ident">NUM_THREADS</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Default number of threads (up to 32).</p>
<p>See: <a href="https://github.com/python/cpython/blob/a635d6386041a2971cf1d39837188ffb8139bcc7/Lib/concurrent/futures/thread.py#L142">CPython's default for this value</a>.</p></div>
</dd>
<dt id="ezq.Task"><code class="name">var <span class="ident">Task</span></code></dt>
<dd>
<div class="desc"><p>Task function signature (any <code>Callable</code>).</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ezq.MsgQ"><code class="name flex">
<span>def <span class="ident">MsgQ</span></span>(<span>maxsize=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a queue object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Queue(self, maxsize=0):
    &#39;&#39;&#39;Returns a queue object&#39;&#39;&#39;
    from .queues import Queue
    return Queue(maxsize, ctx=self.get_context())</code></pre>
</details>
</dd>
<dt id="ezq.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>task:Â Callable[...,Â Any], *args:Â Iterable[Any], num:Â Optional[int]Â =Â None, kind:Â Literal['process',Â 'thread']Â =Â 'process') â€‘>Â Iterator[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Call a function with arguments using multiple workers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>Callable</code></dt>
<dd>function to call</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>list[Any]</code></dt>
<dd>arguments to <code>func</code>. If multiple lists are provided,
they will be passed to <code>zip</code> first.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>number of workers. If <code>None</code>, <code><a title="ezq.NUM_CPUS" href="#ezq.NUM_CPUS">NUM_CPUS</a></code> or
<code><a title="ezq.NUM_THREADS" href="#ezq.NUM_THREADS">NUM_THREADS</a></code> will be used as appropriate. Defaults to <code>None</code>.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code><a title="ezq.ContextName" href="#ezq.ContextName">ContextName</a></code>, optional</dt>
<dd>execution context to use.
Defaults to <code>"process"</code>.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Any</code></dt>
<dd>results from applying the function to the arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(
    task: Task,
    *args: Iterable[Any],
    num: Optional[int] = None,
    kind: ContextName = &#34;process&#34;,
) -&gt; Iterator[Any]:
    &#34;&#34;&#34;Call a function with arguments using multiple workers.

    Args:
        func (Callable): function to call

        *args (list[Any]): arguments to `func`. If multiple lists are provided,
            they will be passed to `zip` first.

        num (int, optional): number of workers. If `None`, `NUM_CPUS` or
            `NUM_THREADS` will be used as appropriate. Defaults to `None`.

        kind (ContextName, optional): execution context to use.
            Defaults to `&#34;process&#34;`.

    Yields:
        Any: results from applying the function to the arguments
    &#34;&#34;&#34;
    q, out = Q(kind=kind), Q(kind=kind)

    def worker(_q: Q, _out: Q) -&gt; None:
        &#34;&#34;&#34;Internal call to `func`.&#34;&#34;&#34;
        for msg in _q.sorted():
            _out.put(data=task(*msg.data), order=msg.order)

    if kind == &#34;process&#34;:
        workers = [Worker.process(worker, q, out) for _ in range(num or NUM_CPUS)]
    elif kind == &#34;thread&#34;:
        workers = [Worker.thread(worker, q, out) for _ in range(num or NUM_THREADS)]
    else:  # pragma: no cover
        raise ValueError(f&#34;Unknown worker context: {kind}&#34;)

    for order, value in enumerate(zip(*args)):
        q.put(value, order=order)
    q.stop(workers)

    for msg in out.end().sorted():
        yield msg.data</code></pre>
</details>
</dd>
<dt id="ezq.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>task:Â Callable[...,Â Any], *args:Â Any, **kwargs:Â Any) â€‘>Â <a title="ezq.Worker" href="#ezq.Worker">Worker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Run a function as a subprocess.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code><a title="ezq.Task" href="#ezq.Task">Task</a></code></dt>
<dd>function to run in each subprocess</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional positional arguments to <code>task</code>.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional keyword arguments to <code>task</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code></dt>
<dd>worker started in a subprocess</dd>
</dl>
<div class="admonition changed">
<p class="admonition-title">Changed:&ensp;2.0.4</p>
<p>This function now returns a <code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code> instead of a <code>Process</code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(task: Task, *args: Any, **kwargs: Any) -&gt; Worker:
    &#34;&#34;&#34;Run a function as a subprocess.

    Args:
        task (Task): function to run in each subprocess

        *args (Any): additional positional arguments to `task`.

        **kwargs (Any): additional keyword arguments to `task`.

    Returns:
        Worker: worker started in a subprocess

    .. changed:: 2.0.4
       This function now returns a `Worker` instead of a `Process`.
    &#34;&#34;&#34;
    return Worker.process(task, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ezq.run_thread"><code class="name flex">
<span>def <span class="ident">run_thread</span></span>(<span>task:Â Callable[...,Â Any], *args:Â Any, **kwargs:Â Any) â€‘>Â <a title="ezq.Worker" href="#ezq.Worker">Worker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Run a function as a thread.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code><a title="ezq.Task" href="#ezq.Task">Task</a></code></dt>
<dd>function to run in each thread</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional positional arguments to <code>task</code>.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional keyword arguments to <code>task</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code></dt>
<dd>worker started in a thread</dd>
</dl>
<div class="admonition changed">
<p class="admonition-title">Changed:&ensp;2.0.4</p>
<p>This function now returns a <code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code> instead of a <code>Thread</code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_thread(task: Task, *args: Any, **kwargs: Any) -&gt; Worker:
    &#34;&#34;&#34;Run a function as a thread.

    Args:
        task (Task): function to run in each thread

        *args (Any): additional positional arguments to `task`.

        **kwargs (Any): additional keyword arguments to `task`.

    Returns:
        Worker: worker started in a thread

    .. changed:: 2.0.4
       This function now returns a `Worker` instead of a `Thread`.
    &#34;&#34;&#34;
    return Worker.thread(task, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ezq.Msg"><code class="flex name class">
<span>class <span class="ident">Msg</span></span>
<span>(</span><span>data:Â AnyÂ =Â None, kind:Â strÂ =Â '', order:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Message for a queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Msg:
    &#34;&#34;&#34;Message for a queue.&#34;&#34;&#34;

    data: Any = None
    &#34;&#34;&#34;Message data to be transmitted.&#34;&#34;&#34;

    kind: str = &#34;&#34;
    &#34;&#34;&#34;Optional marker of message type.&#34;&#34;&#34;

    order: int = 0
    &#34;&#34;&#34;Optional ordering of messages.&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ezq.Msg.data"><code class="name">var <span class="ident">data</span> :Â Any</code></dt>
<dd>
<div class="desc"><p>Message data to be transmitted.</p></div>
</dd>
<dt id="ezq.Msg.kind"><code class="name">var <span class="ident">kind</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Optional marker of message type.</p></div>
</dd>
<dt id="ezq.Msg.order"><code class="name">var <span class="ident">order</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Optional ordering of messages.</p></div>
</dd>
</dl>
</dd>
<dt id="ezq.Q"><code class="flex name class">
<span>class <span class="ident">Q</span></span>
<span>(</span><span>kind:Â Literal['process',Â 'thread']Â =Â 'process')</span>
</code></dt>
<dd>
<div class="desc"><p>Simple message queue.</p>
<p>Construct a queue wrapper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code><a title="ezq.ContextName" href="#ezq.ContextName">ContextName</a></code>, optional</dt>
<dd>If <code>"thread"</code>, construct a lighter-weight
<code>Queue</code> that is thread-safe. Otherwise, construct a full
<code>multiprocess.Queue</code>. Defaults to <code>"process"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Q:
    &#34;&#34;&#34;Simple message queue.&#34;&#34;&#34;

    _q: MsgQ
    &#34;&#34;&#34;Wrapped queue.&#34;&#34;&#34;

    _cache: Optional[List[Msg]] = None
    &#34;&#34;&#34;Cache of queue messages when calling `.items(cache=True)`.&#34;&#34;&#34;

    _timeout: float = 0.05
    &#34;&#34;&#34;Time in seconds to poll the queue.&#34;&#34;&#34;

    def __init__(self, kind: ContextName = &#34;process&#34;):
        &#34;&#34;&#34;Construct a queue wrapper.

        Args:
            kind (ContextName, optional): If `&#34;thread&#34;`, construct a lighter-weight
                `Queue` that is thread-safe. Otherwise, construct a full
                `multiprocess.Queue`. Defaults to `&#34;process&#34;`.
        &#34;&#34;&#34;
        if kind == &#34;process&#34;:
            self._q = Queue()
        elif kind == &#34;thread&#34;:
            self._q = ThreadSafeQueue()
        else:  # pragma: no cover
            raise ValueError(f&#34;Unknown queue type: {kind}&#34;)

    def __getattr__(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Delegate properties to the underlying queue.

        Args:
            name (str): name of the attribute to access

        Returns:
            Any: attribute from the queue
        &#34;&#34;&#34;
        return getattr(self._q, name)

    def __iter__(self) -&gt; Iterator[Msg]:
        &#34;&#34;&#34;Iterate over messages in a queue until `END_MSG` is received.

        Yields:
            Iterator[Msg]: iterate over messages in the queue
        &#34;&#34;&#34;
        while True:
            try:
                msg = self._q.get(block=True, timeout=self._timeout)
                if msg.kind == END_MSG.kind:
                    # We&#39;d really like to put the `END_MSG` back in the queue
                    # to prevent reading past the end, but in practice
                    # this often creates an uncatchable `BrokenPipeError`.
                    # q.put(END_MSG)
                    break
                yield msg
            except Empty:  # pragma: no cover
                # queue might not actually be empty
                # see: https://bugs.python.org/issue20147
                continue

    def items(self, cache: bool = False, sort: bool = False) -&gt; Iterator[Msg]:
        &#34;&#34;&#34;End a queue and read all the current messages.

        Args:
            cache (bool, optional): if `True`, cache the messages. This allows you
                to call this method multiple times to get the same messages.
                Defaults to `False`.

            sort (bool, optional): if `True` messages are sorted by `Msg.order`.
                Defaults to `False`.

        Yields:
            Iterator[Msg]: iterate over messages in the queue
        &#34;&#34;&#34;
        if cache:
            if self._cache is None:  # need to build a cache
                self.end()
                self._cache = list(self.sorted() if sort else self)
            return iter(self._cache)

        # not cached
        self.end()
        return self.sorted() if sort else iter(self)

    def sorted(self, start: int = 0) -&gt; Iterator[Msg]:
        &#34;&#34;&#34;Iterate over messages sorted by `Msg.order`.

        NOTE: `Msg.order` must be incremented by one for each message.
        If there are any gaps, messages after the gap won&#39;t be yielded
        until the end.

        Args:
            start (int, optional): initial message number. Defaults to `0`.

        Yields:
            Iterator[Msg]: message yielded in the correct order
        &#34;&#34;&#34;
        prev = start - 1
        key = attrgetter(&#34;order&#34;)
        waiting: List[Msg] = []
        for item in self:
            if not waiting and key(item) == prev + 1:
                prev += 1
                yield item
                continue

            # items came out of order
            waiting.append(item)
            waiting.sort(key=key, reverse=True)  # sort in-place for performance
            while waiting and key(waiting[-1]) == prev + 1:
                prev += 1
                yield waiting.pop()

        # generator ended; yield any waiting items
        while waiting:
            yield waiting.pop()

    def put(self, data: Any = None, *, kind: str = &#34;&#34;, order: int = 0) -&gt; &#34;Q&#34;:
        &#34;&#34;&#34;Put a message on the queue.

        Args:
            data (Any, optional): message data. Defaults to `None`.

            kind (str, optional): kind of message. Defaults to `&#34;&#34;`.

            order (int, optional): message order. Defaults to `0`.

        Returns:
            Self: self for chaining
        &#34;&#34;&#34;
        if isinstance(data, Msg):
            self._q.put(data)
        else:
            self._q.put(Msg(data=data, kind=kind, order=order))
        return self

    def end(self) -&gt; &#34;Q&#34;:
        &#34;&#34;&#34;Add the `END_MSG` to indicate the end of work.

        Returns:
            Self: self for chaining
        &#34;&#34;&#34;
        self._q.put(END_MSG)
        return self

    def stop(self, workers: Union[Worker, Sequence[Worker]]) -&gt; &#34;Q&#34;:
        &#34;&#34;&#34;Use this queue to notify workers to end and wait for them to join.

        Args:
            workers (Worker, Sequence[Worker]): workers to wait for

        Returns:
            Self: self for chaining
        &#34;&#34;&#34;
        _workers = [workers] if isinstance(workers, Worker) else workers

        for _ in range(len(_workers)):
            self.end()

        for task in _workers:
            task.join()

        return self</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ezq.Q.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self) â€‘>Â <a title="ezq.Q" href="#ezq.Q">Q</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add the <code><a title="ezq.END_MSG" href="#ezq.END_MSG">END_MSG</a></code> to indicate the end of work.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Self</code></dt>
<dd>self for chaining</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self) -&gt; &#34;Q&#34;:
    &#34;&#34;&#34;Add the `END_MSG` to indicate the end of work.

    Returns:
        Self: self for chaining
    &#34;&#34;&#34;
    self._q.put(END_MSG)
    return self</code></pre>
</details>
</dd>
<dt id="ezq.Q.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self, cache:Â boolÂ =Â False, sort:Â boolÂ =Â False) â€‘>Â Iterator[<a title="ezq.Msg" href="#ezq.Msg">Msg</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>End a queue and read all the current messages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cache</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code>, cache the messages. This allows you
to call this method multiple times to get the same messages.
Defaults to <code>False</code>.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if <code>True</code> messages are sorted by <code><a title="ezq.Msg.order" href="#ezq.Msg.order">Msg.order</a></code>.
Defaults to <code>False</code>.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[<a title="ezq.Msg" href="#ezq.Msg">Msg</a>]</code></dt>
<dd>iterate over messages in the queue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self, cache: bool = False, sort: bool = False) -&gt; Iterator[Msg]:
    &#34;&#34;&#34;End a queue and read all the current messages.

    Args:
        cache (bool, optional): if `True`, cache the messages. This allows you
            to call this method multiple times to get the same messages.
            Defaults to `False`.

        sort (bool, optional): if `True` messages are sorted by `Msg.order`.
            Defaults to `False`.

    Yields:
        Iterator[Msg]: iterate over messages in the queue
    &#34;&#34;&#34;
    if cache:
        if self._cache is None:  # need to build a cache
            self.end()
            self._cache = list(self.sorted() if sort else self)
        return iter(self._cache)

    # not cached
    self.end()
    return self.sorted() if sort else iter(self)</code></pre>
</details>
</dd>
<dt id="ezq.Q.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>self, data:Â AnyÂ =Â None, *, kind:Â strÂ =Â '', order:Â intÂ =Â 0) â€‘>Â <a title="ezq.Q" href="#ezq.Q">Q</a></span>
</code></dt>
<dd>
<div class="desc"><p>Put a message on the queue.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Any</code>, optional</dt>
<dd>message data. Defaults to <code>None</code>.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>kind of message. Defaults to <code>""</code>.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>message order. Defaults to <code>0</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Self</code></dt>
<dd>self for chaining</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(self, data: Any = None, *, kind: str = &#34;&#34;, order: int = 0) -&gt; &#34;Q&#34;:
    &#34;&#34;&#34;Put a message on the queue.

    Args:
        data (Any, optional): message data. Defaults to `None`.

        kind (str, optional): kind of message. Defaults to `&#34;&#34;`.

        order (int, optional): message order. Defaults to `0`.

    Returns:
        Self: self for chaining
    &#34;&#34;&#34;
    if isinstance(data, Msg):
        self._q.put(data)
    else:
        self._q.put(Msg(data=data, kind=kind, order=order))
    return self</code></pre>
</details>
</dd>
<dt id="ezq.Q.sorted"><code class="name flex">
<span>def <span class="ident">sorted</span></span>(<span>self, start:Â intÂ =Â 0) â€‘>Â Iterator[<a title="ezq.Msg" href="#ezq.Msg">Msg</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over messages sorted by <code><a title="ezq.Msg.order" href="#ezq.Msg.order">Msg.order</a></code>.</p>
<p>NOTE: <code><a title="ezq.Msg.order" href="#ezq.Msg.order">Msg.order</a></code> must be incremented by one for each message.
If there are any gaps, messages after the gap won't be yielded
until the end.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>initial message number. Defaults to <code>0</code>.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterator[<a title="ezq.Msg" href="#ezq.Msg">Msg</a>]</code></dt>
<dd>message yielded in the correct order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorted(self, start: int = 0) -&gt; Iterator[Msg]:
    &#34;&#34;&#34;Iterate over messages sorted by `Msg.order`.

    NOTE: `Msg.order` must be incremented by one for each message.
    If there are any gaps, messages after the gap won&#39;t be yielded
    until the end.

    Args:
        start (int, optional): initial message number. Defaults to `0`.

    Yields:
        Iterator[Msg]: message yielded in the correct order
    &#34;&#34;&#34;
    prev = start - 1
    key = attrgetter(&#34;order&#34;)
    waiting: List[Msg] = []
    for item in self:
        if not waiting and key(item) == prev + 1:
            prev += 1
            yield item
            continue

        # items came out of order
        waiting.append(item)
        waiting.sort(key=key, reverse=True)  # sort in-place for performance
        while waiting and key(waiting[-1]) == prev + 1:
            prev += 1
            yield waiting.pop()

    # generator ended; yield any waiting items
    while waiting:
        yield waiting.pop()</code></pre>
</details>
</dd>
<dt id="ezq.Q.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, workers:Â Union[<a title="ezq.Worker" href="#ezq.Worker">Worker</a>,Â Sequence[<a title="ezq.Worker" href="#ezq.Worker">Worker</a>]]) â€‘>Â <a title="ezq.Q" href="#ezq.Q">Q</a></span>
</code></dt>
<dd>
<div class="desc"><p>Use this queue to notify workers to end and wait for them to join.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>workers</code></strong> :&ensp;<code><a title="ezq.Worker" href="#ezq.Worker">Worker</a>, Sequence[<a title="ezq.Worker" href="#ezq.Worker">Worker</a>]</code></dt>
<dd>workers to wait for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Self</code></dt>
<dd>self for chaining</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self, workers: Union[Worker, Sequence[Worker]]) -&gt; &#34;Q&#34;:
    &#34;&#34;&#34;Use this queue to notify workers to end and wait for them to join.

    Args:
        workers (Worker, Sequence[Worker]): workers to wait for

    Returns:
        Self: self for chaining
    &#34;&#34;&#34;
    _workers = [workers] if isinstance(workers, Worker) else workers

    for _ in range(len(_workers)):
        self.end()

    for task in _workers:
        task.join()

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ezq.Worker"><code class="flex name class">
<span>class <span class="ident">Worker</span></span>
<span>(</span><span>context:Â Union[multiprocess.context.Process,Â threading.Thread])</span>
</code></dt>
<dd>
<div class="desc"><p>A function running in a <code>Process</code> or <code>Thread</code>.</p>
<p>Construct a worker from a context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code><a title="ezq.Context" href="#ezq.Context">Context</a></code></dt>
<dd>a <code>Process</code> or a <code>Thread</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Worker:
    &#34;&#34;&#34;A function running in a `Process` or `Thread`.&#34;&#34;&#34;

    _worker: Context
    &#34;&#34;&#34;Execution context.&#34;&#34;&#34;

    @staticmethod
    def process(task: Task, *args: Any, **kwargs: Any) -&gt; &#34;Worker&#34;:
        &#34;&#34;&#34;Create a `Process`-based `Worker`.

        Args:
            task (Task): function to run
            *args (Any): additional arguments to `task`
            **kwargs (Any): additional keyword arguments to `task`

        Returns:
            Worker: wrapped worker.
        &#34;&#34;&#34;
        # NOTE: On MacOS, python 3.8 switched the default method
        # from &#34;fork&#34; to &#34;spawn&#34; because fork is considered dangerous.
        # Some posts say &#34;forkserver&#34; should be ok.
        # See:  https://bugs.python.org/issue?@action=redirect&amp;bpo=33725
        #
        # if IS_MACOS:
        #     ctx = get_context(&#34;forkserver&#34;)
        # else:
        #     ctx = get_context()
        return Worker(Process(daemon=True, target=task, args=args, kwargs=kwargs))

    @staticmethod
    def thread(task: Task, *args: Any, **kwargs: Any) -&gt; &#34;Worker&#34;:
        &#34;&#34;&#34;Create a `Thread`-based `Worker`.

        Args:
            task (Task): function to run
            *args (Any): additional arguments to `task`
            **kwargs (Any): additional keyword arguments to `task`

        Returns:
            Worker: wrapped worker.
        &#34;&#34;&#34;
        return Worker(Thread(daemon=False, target=task, args=args, kwargs=kwargs))

    def __init__(self, context: Context):
        &#34;&#34;&#34;Construct a worker from a context.

        Args:
            context (Context): a `Process` or a `Thread`
        &#34;&#34;&#34;
        self._worker = context
        self._worker.start()

    def __getattr__(self, name: str) -&gt; Any:
        &#34;&#34;&#34;Delegate properties to the underlying task.

        Args:
            name (str): attribute name

        Returns:
            Any: attribute from the task
        &#34;&#34;&#34;
        return getattr(self._worker, name)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ezq.Worker.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>task:Â Callable[...,Â Any], *args:Â Any, **kwargs:Â Any) â€‘>Â <a title="ezq.Worker" href="#ezq.Worker">Worker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a <code>Process</code>-based <code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code><a title="ezq.Task" href="#ezq.Task">Task</a></code></dt>
<dd>function to run</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional arguments to <code>task</code></dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional keyword arguments to <code>task</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code></dt>
<dd>wrapped worker.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process(task: Task, *args: Any, **kwargs: Any) -&gt; &#34;Worker&#34;:
    &#34;&#34;&#34;Create a `Process`-based `Worker`.

    Args:
        task (Task): function to run
        *args (Any): additional arguments to `task`
        **kwargs (Any): additional keyword arguments to `task`

    Returns:
        Worker: wrapped worker.
    &#34;&#34;&#34;
    # NOTE: On MacOS, python 3.8 switched the default method
    # from &#34;fork&#34; to &#34;spawn&#34; because fork is considered dangerous.
    # Some posts say &#34;forkserver&#34; should be ok.
    # See:  https://bugs.python.org/issue?@action=redirect&amp;bpo=33725
    #
    # if IS_MACOS:
    #     ctx = get_context(&#34;forkserver&#34;)
    # else:
    #     ctx = get_context()
    return Worker(Process(daemon=True, target=task, args=args, kwargs=kwargs))</code></pre>
</details>
</dd>
<dt id="ezq.Worker.thread"><code class="name flex">
<span>def <span class="ident">thread</span></span>(<span>task:Â Callable[...,Â Any], *args:Â Any, **kwargs:Â Any) â€‘>Â <a title="ezq.Worker" href="#ezq.Worker">Worker</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a <code>Thread</code>-based <code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code><a title="ezq.Task" href="#ezq.Task">Task</a></code></dt>
<dd>function to run</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional arguments to <code>task</code></dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Any</code></dt>
<dd>additional keyword arguments to <code>task</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code></dt>
<dd>wrapped worker.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def thread(task: Task, *args: Any, **kwargs: Any) -&gt; &#34;Worker&#34;:
    &#34;&#34;&#34;Create a `Thread`-based `Worker`.

    Args:
        task (Task): function to run
        *args (Any): additional arguments to `task`
        **kwargs (Any): additional keyword arguments to `task`

    Returns:
        Worker: wrapped worker.
    &#34;&#34;&#34;
    return Worker(Thread(daemon=False, target=task, args=args, kwargs=kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#why">Why?</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#example-quick-start">Example: Quick Start</a></li>
<li><a href="#example-sum-messages">Example: Sum Messages</a></li>
<li><a href="#typical-worker-lifecycle">Typical worker lifecycle</a></li>
<li><a href="#process-vs-thread">Process vs Thread</a></li>
<li><a href="#create-queues">Create queues</a></li>
<li><a href="#a-worker-task-is-just-a-function">A worker task is just a function</a></li>
<li><a href="#create-workers">Create workers</a></li>
<li><a href="#send-data">Send data</a></li>
<li><a href="#beware-pickle">Beware pickle</a></li>
<li><a href="#beware-shared-state">Beware shared state</a></li>
<li><a href="#iterate-over-messages">Iterate over messages</a></li>
<li><a href="#end-the-queue">End the queue</a></li>
<li><a href="#process-results">Process results</a></li>
<li><a href="#example-read-and-write-queues">Example: Read and Write Queues</a></li>
<li><a href="#license">License</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="ezq.Context" href="#ezq.Context">Context</a></code></li>
<li><code><a title="ezq.ContextName" href="#ezq.ContextName">ContextName</a></code></li>
<li><code><a title="ezq.END_MSG" href="#ezq.END_MSG">END_MSG</a></code></li>
<li><code><a title="ezq.IS_MACOS" href="#ezq.IS_MACOS">IS_MACOS</a></code></li>
<li><code><a title="ezq.NUM_CPUS" href="#ezq.NUM_CPUS">NUM_CPUS</a></code></li>
<li><code><a title="ezq.NUM_THREADS" href="#ezq.NUM_THREADS">NUM_THREADS</a></code></li>
<li><code><a title="ezq.Task" href="#ezq.Task">Task</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ezq.MsgQ" href="#ezq.MsgQ">MsgQ</a></code></li>
<li><code><a title="ezq.map" href="#ezq.map">map</a></code></li>
<li><code><a title="ezq.run" href="#ezq.run">run</a></code></li>
<li><code><a title="ezq.run_thread" href="#ezq.run_thread">run_thread</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ezq.Msg" href="#ezq.Msg">Msg</a></code></h4>
<ul class="">
<li><code><a title="ezq.Msg.data" href="#ezq.Msg.data">data</a></code></li>
<li><code><a title="ezq.Msg.kind" href="#ezq.Msg.kind">kind</a></code></li>
<li><code><a title="ezq.Msg.order" href="#ezq.Msg.order">order</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ezq.Q" href="#ezq.Q">Q</a></code></h4>
<ul class="">
<li><code><a title="ezq.Q.end" href="#ezq.Q.end">end</a></code></li>
<li><code><a title="ezq.Q.items" href="#ezq.Q.items">items</a></code></li>
<li><code><a title="ezq.Q.put" href="#ezq.Q.put">put</a></code></li>
<li><code><a title="ezq.Q.sorted" href="#ezq.Q.sorted">sorted</a></code></li>
<li><code><a title="ezq.Q.stop" href="#ezq.Q.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ezq.Worker" href="#ezq.Worker">Worker</a></code></h4>
<ul class="">
<li><code><a title="ezq.Worker.process" href="#ezq.Worker.process">process</a></code></li>
<li><code><a title="ezq.Worker.thread" href="#ezq.Worker.thread">thread</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>